; линейно рекурсивный процесс
; - процесс растет, затем сжимается
; - требует больше памяти для хранения отложенных операций
; - линейная зависимость объема памяти от n
; n! = n * (n - 1)!
; (factorial 4)
; (* 4 (factorial 3))
; (* 4 (3 (factorial 2)))
; (* 4 (* 3 (* 2 (factorial 1))))
; (* 4 (* 3 (* 2 1)))
; (* 4 (* 3 2))
; (* 4 6)
; 24
; 4! = 4 * 3! = 4 * 3 * 2! = 4 * 3 * 2 * 2! = 4 * 3 * 2 * 1
(define (factorial x)
    (if (= x 1)
        1
        (* x (factorial (- x 1)))))

(factorial 4)

; линейно итеративный процесс
; - не растет и не сжимается
; - на каждом шаге нужно знать только текущие значения переменных
; - число шагов (итераций) зависит от n
; n! = 1 * 2 * 3 * 4
; 4! => 
; произведение = 1, счетчик = 1
; произведение = 1, счетчик = 2
; произведение = 2, счетчик = 3
; произведение = 6, счетчик = 4
; произведение = 24, счетчик = 5 (завершаем итерации)
(define (factorial_v2 x)
    (define (iter product counter)
        (if (> counter x)
            product
            (iter (* counter product)
                  (+ counter 1))))
    (iter 1 1))

(factorial_v2 4)

; поддержка хвостовой рекурсии - возможность компилятора вычислять рекурсивную процедуру с помощью итеративного процесса

; Упражнение 1.9

(define (inc x)
    (+ x 1))

(define (dec x)
    (- x 1))

(define (plus a b)
    (if (= a 0)
        b
        (inc (+ (dec a) b))))
(plus 4 5)
; (+ 4 5)
; (inc (+ 3 5))
; (inc (inc (+ 2 5)))
; (inc (inc (inc (+ 1 5))))
; (inc (inc (inc (inc (+ 0 5)))))
; (inc (inc (inc (inc 5))))
; (inc (inc (inc 6)))
; (inc (inc 7))
; (inc 8)
; 9
; линейно рекурсивный процесс (расширение-сжатие)

(define (plus_v2 a b)
    (if (= a 0)
        b
        (+ (dec a) (inc b))))
; (+ 4 5)
; (+ 3 6)
; (+ 2 7)
; (+ 1 8)
; (+ 0 9)
; 9
; линейно итеративный процесс

; Упражнение 1.10
(define (A x y)
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (else (A (- x 1)
                   (A x (- y 1))))))

; (A 1 10)
; (A 0 (A 1 9))
; (* 2 (A 1 9))
; (* 2 (A 0 (A (1 8)))
; (* 2 (* 2 (A (1 8)))
; (* 2 (* 2 (A 0 (A 1 7)))
; (* 2 (* 2 (* 2 (A 1 7)))
; (* 2 (* 2 (* 2 (A 0 (A 1 6))))
; (* 2 (* 2 (* 2 (* 2 (A 1 6))))
; (* 2 (* 2 (* 2 (* 2 (A 0 (A 1 5)))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (A 1 5)))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (A 0 (A 1 4))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (A 1 4))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (A 0 (A 1 3)))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (A 1 3)))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (A 0 (A 1 3))))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (A 1 3))))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (A 0 (A 1 2)))))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (A 1 2)))))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (A 0 (A 1 1))))))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (A 1 1))))))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 2)))))))))
; 2^10 = 1024
(A 2 10)

; (A 2 4)
; (A 1 (A 2 3))
; (A 1 (A 1 (A 2 2))
; (A 1 (A 1 (A 1 (A 2 1)))
; (A 1 (A 1 (A 1 2)))
; 2^2^2^2 = 65536
(A 2 4)

; (A 3 3)
; (A 2 (A 3 2))
; (A 2 (A 3 2))
; (A 2 (A 2 (A 3 1)))
; (A 2 (A 2 2))
; (A 2 (A 1 (A 2 1)))
; (A 2 (A 1 2))
; (A 2 4)
; 2^2^2^2 = 65536
(A 3 3)

(define (f n) (A 0 n))
; 2n

(define (g n) (A 1 n))
; 2^n, n>0

(define (h n) (A 2 n))
; 2^2^...^2, n>0

(define (k n) (* 5 n n))
; 5n^2